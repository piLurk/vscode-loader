/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["__icube_loader__"] = factory();
	else
		root["__icube_loader__"] = factory();
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/configuration.ts":
/*!***********************************!*\
  !*** ./src/core/configuration.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Configuration: () => (/* binding */ Configuration),\n/* harmony export */   ConfigurationOptionsUtil: () => (/* binding */ ConfigurationOptionsUtil),\n/* harmony export */   ensureError: () => (/* binding */ ensureError)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction ensureError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n  const result = new Error(err.message || String(err) || \"Unknown Error\");\n  if (err.stack) {\n    result.stack = err.stack;\n  }\n  return result;\n}\n\n/**\n * The signature for the loader's AMD \"define\" function.\n */\n\n/**\n * The signature for the loader's AMD \"require\" function.\n */\n\nclass ConfigurationOptionsUtil {\n  /**\n   * Ensure configuration options make sense\n   */\n  static validateConfigurationOptions(options) {\n    function defaultOnError(err) {\n      if (err.phase === \"loading\") {\n        console.error('Loading \"' + err.moduleId + '\" failed');\n        console.error(err);\n        console.error(\"Here are the modules that depend on it:\");\n        console.error(err.neededBy);\n        return;\n      }\n      if (err.phase === \"factory\") {\n        console.error('The factory function of \"' + err.moduleId + '\" has thrown an exception');\n        console.error(err);\n        console.error(\"Here are the modules that depend on it:\");\n        console.error(err.neededBy);\n        return;\n      }\n    }\n    options = options || {};\n    if (typeof options.baseUrl !== \"string\") {\n      options.baseUrl = \"\";\n    }\n    if (typeof options.isBuild !== \"boolean\") {\n      options.isBuild = false;\n    }\n    if (typeof options.paths !== \"object\") {\n      options.paths = {};\n    }\n    if (typeof options.config !== \"object\") {\n      options.config = {};\n    }\n    if (typeof options.catchError === \"undefined\") {\n      options.catchError = false;\n    }\n    if (typeof options.recordStats === \"undefined\") {\n      options.recordStats = false;\n    }\n    if (typeof options.urlArgs !== \"string\") {\n      options.urlArgs = \"\";\n    }\n    if (typeof options.onError !== \"function\") {\n      options.onError = defaultOnError;\n    }\n    if (!Array.isArray(options.ignoreDuplicateModules)) {\n      options.ignoreDuplicateModules = [];\n    }\n    if (options.baseUrl.length > 0) {\n      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.endsWith(options.baseUrl, \"/\")) {\n        options.baseUrl += \"/\";\n      }\n    }\n    if (typeof options.cspNonce !== \"string\") {\n      options.cspNonce = \"\";\n    }\n    if (typeof options.preferScriptTags === \"undefined\") {\n      options.preferScriptTags = false;\n    }\n    if (options.nodeCachedData && typeof options.nodeCachedData === \"object\") {\n      if (typeof options.nodeCachedData.seed !== \"string\") {\n        options.nodeCachedData.seed = \"seed\";\n      }\n      if (typeof options.nodeCachedData.writeDelay !== \"number\" || options.nodeCachedData.writeDelay < 0) {\n        options.nodeCachedData.writeDelay = 1000 * 7;\n      }\n      if (!options.nodeCachedData.path || typeof options.nodeCachedData.path !== \"string\") {\n        const err = ensureError(new Error(\"INVALID cached data configuration, 'path' MUST be set\"));\n        err.phase = \"configuration\";\n        options.onError(err);\n        options.nodeCachedData = undefined;\n      }\n    }\n    return options;\n  }\n  static mergeConfigurationOptions() {\n    let overwrite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let result = _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.recursiveClone(base || {});\n\n    // Merge known properties and overwrite the unknown ones\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.forEachProperty(overwrite, (key, value) => {\n      if (key === \"ignoreDuplicateModules\" && typeof result.ignoreDuplicateModules !== \"undefined\") {\n        result.ignoreDuplicateModules = result.ignoreDuplicateModules.concat(value);\n      } else if (key === \"paths\" && typeof result.paths !== \"undefined\") {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.forEachProperty(value, (key2, value2) => result.paths[key2] = value2);\n      } else if (key === \"config\" && typeof result.config !== \"undefined\") {\n        _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.forEachProperty(value, (key2, value2) => result.config[key2] = value2);\n      } else {\n        result[key] = _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.recursiveClone(value);\n      }\n    });\n    return ConfigurationOptionsUtil.validateConfigurationOptions(result);\n  }\n}\nclass Configuration {\n  /**\n   * Generated from the `ignoreDuplicateModules` configuration option.\n   */\n\n  /**\n   * Generated from the `paths` configuration option. These are sorted with the longest `from` first.\n   */\n\n  constructor(env, options) {\n    this._env = env;\n    this.options = ConfigurationOptionsUtil.mergeConfigurationOptions(options);\n    this._createIgnoreDuplicateModulesMap();\n    this._createSortedPathsRules();\n    if (this.options.baseUrl === \"\") {\n      if (this.options.nodeRequire && this.options.nodeRequire.main && this.options.nodeRequire.main.filename && this._env.isNode) {\n        let nodeMain = this.options.nodeRequire.main.filename;\n        let dirnameIndex = Math.max(nodeMain.lastIndexOf(\"/\"), nodeMain.lastIndexOf(\"\\\\\"));\n        this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);\n      }\n    }\n  }\n  _createIgnoreDuplicateModulesMap() {\n    // Build a map out of the ignoreDuplicateModules array\n    this.ignoreDuplicateModulesMap = {};\n    for (let i = 0; i < this.options.ignoreDuplicateModules.length; i++) {\n      this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[i]] = true;\n    }\n  }\n  _createSortedPathsRules() {\n    // Create an array our of the paths rules, sorted descending by length to\n    // result in a more specific -> less specific order\n    this.sortedPathsRules = [];\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.forEachProperty(this.options.paths, (from, to) => {\n      if (!Array.isArray(to)) {\n        this.sortedPathsRules.push({\n          from: from,\n          to: [to]\n        });\n      } else {\n        this.sortedPathsRules.push({\n          from: from,\n          to: to\n        });\n      }\n    });\n    this.sortedPathsRules.sort((a, b) => {\n      return b.from.length - a.from.length;\n    });\n  }\n\n  /**\n   * Clone current configuration and overwrite options selectively.\n   * @param options The selective options to overwrite with.\n   * @result A new configuration\n   */\n  cloneAndMerge(options) {\n    return new Configuration(this._env, ConfigurationOptionsUtil.mergeConfigurationOptions(options, this.options));\n  }\n\n  /**\n   * Get current options bag. Useful for passing it forward to plugins.\n   */\n  getOptionsLiteral() {\n    return this.options;\n  }\n  _applyPaths(moduleId) {\n    let pathRule;\n    for (let i = 0, len = this.sortedPathsRules.length; i < len; i++) {\n      pathRule = this.sortedPathsRules[i];\n      if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.startsWith(moduleId, pathRule.from)) {\n        let result = [];\n        for (let j = 0, lenJ = pathRule.to.length; j < lenJ; j++) {\n          result.push(pathRule.to[j] + moduleId.substr(pathRule.from.length));\n        }\n        return result;\n      }\n    }\n    return [moduleId];\n  }\n  _addUrlArgsToUrl(url) {\n    if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.containsQueryString(url)) {\n      return url + \"&\" + this.options.urlArgs;\n    } else {\n      return url + \"?\" + this.options.urlArgs;\n    }\n  }\n  _addUrlArgsIfNecessaryToUrl(url) {\n    if (this.options.urlArgs) {\n      return this._addUrlArgsToUrl(url);\n    }\n    return url;\n  }\n  _addUrlArgsIfNecessaryToUrls(urls) {\n    if (this.options.urlArgs) {\n      for (let i = 0, len = urls.length; i < len; i++) {\n        urls[i] = this._addUrlArgsToUrl(urls[i]);\n      }\n    }\n    return urls;\n  }\n\n  /**\n   * Transform a module id to a location. Appends .js to module ids\n   */\n  moduleIdToPaths(moduleId) {\n    if (this._env.isNode) {\n      const isNodeModule = this.options.amdModulesPattern instanceof RegExp && !this.options.amdModulesPattern.test(moduleId);\n      if (isNodeModule) {\n        // This is a node module...\n        if (this.isBuild()) {\n          // ...and we are at build time, drop it\n          return [\"empty:\"];\n        } else {\n          // ...and at runtime we create a `shortcut`-path\n          return [\"node|\" + moduleId];\n        }\n      }\n    }\n    let result = moduleId;\n    let results;\n    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.endsWith(result, \".js\") && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.isAbsolutePath(result)) {\n      results = this._applyPaths(result);\n      for (let i = 0, len = results.length; i < len; i++) {\n        if (this.isBuild() && results[i] === \"empty:\") {\n          continue;\n        }\n        if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.isAbsolutePath(results[i])) {\n          results[i] = this.options.baseUrl + results[i];\n        }\n        if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.endsWith(results[i], \".js\") && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.containsQueryString(results[i])) {\n          results[i] = results[i] + \".js\";\n        }\n      }\n    } else {\n      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.endsWith(result, \".js\") && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.containsQueryString(result)) {\n        result = result + \".js\";\n      }\n      results = [result];\n    }\n    return this._addUrlArgsIfNecessaryToUrls(results);\n  }\n\n  /**\n   * Transform a module id or url to a location.\n   */\n  requireToUrl(url) {\n    let result = url;\n    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.isAbsolutePath(result)) {\n      result = this._applyPaths(result)[0];\n      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.isAbsolutePath(result)) {\n        result = this.options.baseUrl + result;\n      }\n    }\n    return this._addUrlArgsIfNecessaryToUrl(result);\n  }\n\n  /**\n   * Flag to indicate if current execution is as part of a build.\n   */\n  isBuild() {\n    return this.options.isBuild;\n  }\n  shouldInvokeFactory(strModuleId) {\n    if (!this.options.isBuild) {\n      // outside of a build, all factories should be invoked\n      return true;\n    }\n    // during a build, only explicitly marked or anonymous modules get their factories invoked\n    if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.isAnonymousModule(strModuleId)) {\n      return true;\n    }\n    if (this.options.buildForceInvokeFactory && this.options.buildForceInvokeFactory[strModuleId]) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Test if module `moduleId` is expected to be defined multiple times\n   */\n  isDuplicateMessageIgnoredFor(moduleId) {\n    return this.ignoreDuplicateModulesMap.hasOwnProperty(moduleId);\n  }\n\n  /**\n   * Get the configuration settings for the provided module id\n   */\n  getConfigForModule(moduleId) {\n    if (this.options.config) {\n      return this.options.config[moduleId];\n    }\n  }\n\n  /**\n   * Should errors be caught when executing module factories?\n   */\n  shouldCatchError() {\n    return this.options.catchError;\n  }\n\n  /**\n   * Should statistics be recorded?\n   */\n  shouldRecordStats() {\n    return this.options.recordStats;\n  }\n\n  /**\n   * Forward an error to the error handler.\n   */\n  onError(err) {\n    this.options.onError(err);\n  }\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/configuration.ts?");

/***/ }),

/***/ "./src/core/env.ts":
/*!*************************!*\
  !*** ./src/core/env.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   _commonjsGlobal: () => (/* binding */ _commonjsGlobal),\n/* harmony export */   globalVar: () => (/* binding */ globalVar),\n/* harmony export */   isWindows: () => (/* binding */ isWindows)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n * Please make sure to make edits in the .ts file at https://github.com/microsoft/vscode-loader/\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *--------------------------------------------------------------------------------------------*/\n\nconst isWindows = () => {\n  if (typeof navigator !== \"undefined\") {\n    // 判定错误\n    if (navigator.userAgent && globalThis.window) {\n      return true;\n    }\n  }\n  if (typeof process !== \"undefined\") {\n    return process.platform === \"win32\";\n  }\n  return false;\n};\nconst _amdLoaderGlobal = isWindows() ? {} : globalThis;\nconst _commonjsGlobal = typeof global === \"object\" ? global : {};\nconst globalVar = _amdLoaderGlobal;\nclass Environment {\n  get isWindows() {\n    this._detect();\n    return this._isWindows;\n  }\n  get isNode() {\n    this._detect();\n    return this._isNode;\n  }\n  get isElectronRenderer() {\n    this._detect();\n    return this._isElectronRenderer;\n  }\n  get isWebWorker() {\n    this._detect();\n    return this._isWebWorker;\n  }\n  get isElectronNodeIntegrationWebWorker() {\n    this._detect();\n    return this._isElectronNodeIntegrationWebWorker;\n  }\n  constructor() {\n    this._detected = false;\n    this._isWindows = false;\n    this._isNode = false;\n    this._isElectronRenderer = false;\n    this._isWebWorker = false;\n    this._isElectronNodeIntegrationWebWorker = false;\n  }\n  _detect() {\n    if (this._detected) {\n      return;\n    }\n    this._detected = true;\n    this._isWindows = Environment._isWindows();\n    this._isNode =  true && \"exports\" in module && typeof process !== \"undefined\" && process.versions && !!process.versions.node;\n    this._isElectronRenderer = typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.electron !== \"undefined\" && process.type === \"renderer\";\n    this._isWebWorker = typeof globalVar.importScripts === \"function\";\n    this._isElectronNodeIntegrationWebWorker = this._isWebWorker && typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.electron !== \"undefined\" && process.type === \"worker\";\n  }\n  static _isWindows = isWindows;\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/env.ts?");

/***/ }),

/***/ "./src/core/loaderEvents.ts":
/*!**********************************!*\
  !*** ./src/core/loaderEvents.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoaderEvent: () => (/* binding */ LoaderEvent),\n/* harmony export */   LoaderEventRecorder: () => (/* binding */ LoaderEventRecorder),\n/* harmony export */   LoaderEventType: () => (/* binding */ LoaderEventType),\n/* harmony export */   NullLoaderEventRecorder: () => (/* binding */ NullLoaderEventRecorder)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nlet LoaderEventType = /*#__PURE__*/function (LoaderEventType) {\n  LoaderEventType[LoaderEventType[\"LoaderAvailable\"] = 1] = \"LoaderAvailable\";\n  LoaderEventType[LoaderEventType[\"BeginLoadingScript\"] = 10] = \"BeginLoadingScript\";\n  LoaderEventType[LoaderEventType[\"EndLoadingScriptOK\"] = 11] = \"EndLoadingScriptOK\";\n  LoaderEventType[LoaderEventType[\"EndLoadingScriptError\"] = 12] = \"EndLoadingScriptError\";\n  LoaderEventType[LoaderEventType[\"BeginInvokeFactory\"] = 21] = \"BeginInvokeFactory\";\n  LoaderEventType[LoaderEventType[\"EndInvokeFactory\"] = 22] = \"EndInvokeFactory\";\n  LoaderEventType[LoaderEventType[\"NodeBeginEvaluatingScript\"] = 31] = \"NodeBeginEvaluatingScript\";\n  LoaderEventType[LoaderEventType[\"NodeEndEvaluatingScript\"] = 32] = \"NodeEndEvaluatingScript\";\n  LoaderEventType[LoaderEventType[\"NodeBeginNativeRequire\"] = 33] = \"NodeBeginNativeRequire\";\n  LoaderEventType[LoaderEventType[\"NodeEndNativeRequire\"] = 34] = \"NodeEndNativeRequire\";\n  LoaderEventType[LoaderEventType[\"CachedDataFound\"] = 60] = \"CachedDataFound\";\n  LoaderEventType[LoaderEventType[\"CachedDataMissed\"] = 61] = \"CachedDataMissed\";\n  LoaderEventType[LoaderEventType[\"CachedDataRejected\"] = 62] = \"CachedDataRejected\";\n  LoaderEventType[LoaderEventType[\"CachedDataCreated\"] = 63] = \"CachedDataCreated\";\n  return LoaderEventType;\n}({});\nclass LoaderEvent {\n  constructor(type, detail, timestamp) {\n    this.type = type;\n    this.detail = detail;\n    this.timestamp = timestamp;\n  }\n}\nclass LoaderEventRecorder {\n  constructor(loaderAvailableTimestamp) {\n    this._events = [new LoaderEvent(LoaderEventType.LoaderAvailable, \"\", loaderAvailableTimestamp)];\n  }\n  record(type, detail) {\n    this._events.push(new LoaderEvent(type, detail, _utils__WEBPACK_IMPORTED_MODULE_0__.Utilities.getHighPerformanceTimestamp()));\n  }\n  getEvents() {\n    return this._events;\n  }\n}\nclass NullLoaderEventRecorder {\n  static INSTANCE = new NullLoaderEventRecorder();\n  record(type, detail) {\n    // Nothing to do\n  }\n  getEvents() {\n    return [];\n  }\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/loaderEvents.ts?");

/***/ }),

/***/ "./src/core/main.ts":
/*!**************************!*\
  !*** ./src/core/main.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalVar: () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_0__.globalVar),\n/* harmony export */   initLoader: () => (/* binding */ initLoader)\n/* harmony export */ });\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ \"./src/core/env.ts\");\n/* harmony import */ var _moduleManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./moduleManager */ \"./src/core/moduleManager.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.ts\");\n/* harmony import */ var _scriptLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scriptLoader */ \"./src/core/scriptLoader.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n// Limitation: To load jquery through the loader, always require 'jquery' and add a path for it in the loader configuration\n\n\n\n\nvar define;\nconst env = new _env__WEBPACK_IMPORTED_MODULE_0__.Environment();\nlet moduleManager;\nconst DefineFunc = function (id, dependencies, callback) {\n  if (typeof id !== \"string\") {\n    callback = dependencies;\n    dependencies = id;\n    id = null;\n  }\n  if (typeof dependencies !== \"object\" || !Array.isArray(dependencies)) {\n    callback = dependencies;\n    dependencies = null;\n  }\n  if (!dependencies) {\n    dependencies = [\"require\", \"exports\", \"module\"];\n  }\n  if (id) {\n    moduleManager.defineModule(id, dependencies, callback, null, null);\n  } else {\n    moduleManager.enqueueDefineAnonymousModule(dependencies, callback);\n  }\n};\nDefineFunc.amd = {\n  jQuery: true\n};\nconst _requireFunc_config = function (params) {\n  let shouldOverwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  moduleManager.configure(params, shouldOverwrite);\n};\nconst RequireFunc = function () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Object && !Array.isArray(arguments[0])) {\n      _requireFunc_config(arguments[0]);\n      return;\n    }\n    if (typeof arguments[0] === \"string\") {\n      return moduleManager.synchronousRequire(arguments[0]);\n    }\n  }\n  if (arguments.length === 2 || arguments.length === 3) {\n    if (Array.isArray(arguments[0])) {\n      moduleManager.defineModule(_utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.generateAnonymousModule(), arguments[0], arguments[1], arguments[2], null);\n      return;\n    }\n  }\n  throw new Error(\"Unrecognized require call\");\n};\nRequireFunc.config = _requireFunc_config;\nRequireFunc.getConfig = function () {\n  return moduleManager.getConfig().getOptionsLiteral();\n};\nRequireFunc.reset = function () {\n  moduleManager = moduleManager.reset();\n};\nRequireFunc.getBuildInfo = function () {\n  return moduleManager.getBuildInfo();\n};\nRequireFunc.getStats = function () {\n  return moduleManager.getLoaderEvents();\n};\nRequireFunc.define = DefineFunc;\nfunction init() {\n  if (typeof globalThis.require !== \"undefined\" || typeof require !== \"undefined\") {\n    // https://webpack.docschina.org/api/module-variables/#__non_webpack_require__-webpack-specific\n    // 避免 require 被 webpack 解析\n    const _nodeRequire = _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.require || require; // webpack-ignore\n    if (typeof _nodeRequire === \"function\" && typeof _nodeRequire.resolve === \"function\") {\n      // re-expose node's require function\n      const nodeRequire = (0,_scriptLoader__WEBPACK_IMPORTED_MODULE_3__.ensureRecordedNodeRequire)(moduleManager.getRecorder(), _nodeRequire);\n      _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.nodeRequire = nodeRequire;\n      RequireFunc.nodeRequire = nodeRequire;\n      RequireFunc.__$__nodeRequire = nodeRequire;\n    }\n  }\n  if (env.isNode && !env.isElectronRenderer && !env.isElectronNodeIntegrationWebWorker) {\n    // module.exports = RequireFunc;\n    module.exports = RequireFunc;\n\n    // exports.loader = RequireFunc;\n    _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.loader = RequireFunc;\n    // globalVar.require = RequireFunc;\n  } else {\n    if (!env.isElectronRenderer) {\n      _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.define = DefineFunc;\n    }\n    _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.require = RequireFunc;\n  }\n}\nconst initLoader = () => {\n  _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.setUniqueID = function (id) {\n    this.__uniqueID__ = id;\n  };\n  _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.getUniqueID = function () {\n    return this.__uniqueID__;\n  };\n  if (typeof _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.define !== \"function\" || !_env__WEBPACK_IMPORTED_MODULE_0__.globalVar.define.amd) {\n    moduleManager = new _moduleManager__WEBPACK_IMPORTED_MODULE_1__.ModuleManager(env, (0,_scriptLoader__WEBPACK_IMPORTED_MODULE_3__.createScriptLoader)(env), DefineFunc, RequireFunc, _utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.getHighPerformanceTimestamp());\n\n    // The global variable require can configure the loader\n    if (typeof _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.require !== \"undefined\" && typeof _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.require !== \"function\") {\n      RequireFunc.config(_env__WEBPACK_IMPORTED_MODULE_0__.globalVar.require);\n    }\n\n    // This define is for the local closure defined in node in the case that the loader is concatenated\n    define = function () {\n      return DefineFunc.apply(null, arguments);\n    };\n    define.amd = DefineFunc.amd;\n    if (typeof doNotInitLoader === \"undefined\") {\n      init();\n    }\n  }\n  return _env__WEBPACK_IMPORTED_MODULE_0__.globalVar;\n};\n\n// 非 window 下，直接初始化。\nif (!(0,_env__WEBPACK_IMPORTED_MODULE_0__.isWindows)()) {\n  initLoader();\n}\nglobalThis.aaa = _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.loader;\n\n//# sourceURL=webpack://__icube_loader__/./src/core/main.ts?");

/***/ }),

/***/ "./src/core/moduleManager.ts":
/*!***********************************!*\
  !*** ./src/core/moduleManager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Module: () => (/* binding */ Module),\n/* harmony export */   ModuleId: () => (/* binding */ ModuleId),\n/* harmony export */   ModuleIdResolver: () => (/* binding */ ModuleIdResolver),\n/* harmony export */   ModuleManager: () => (/* binding */ ModuleManager),\n/* harmony export */   PluginDependency: () => (/* binding */ PluginDependency),\n/* harmony export */   RegularDependency: () => (/* binding */ RegularDependency)\n/* harmony export */ });\n/* harmony import */ var _configuration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configuration */ \"./src/core/configuration.ts\");\n/* harmony import */ var _loaderEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loaderEvents */ \"./src/core/loaderEvents.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.ts\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env */ \"./src/core/env.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n// ------------------------------------------------------------------------\n// ModuleIdResolver\n\nclass ModuleIdResolver {\n  static ROOT = new ModuleIdResolver(\"\");\n  constructor(fromModuleId) {\n    let lastSlash = fromModuleId.lastIndexOf(\"/\");\n    if (lastSlash !== -1) {\n      this.fromModulePath = fromModuleId.substr(0, lastSlash + 1);\n    } else {\n      this.fromModulePath = \"\";\n    }\n  }\n\n  /**\n   * Normalize 'a/../name' to 'name', etc.\n   */\n  static _normalizeModuleId(moduleId) {\n    let r = moduleId,\n      pattern;\n\n    // replace /./ => /\n    pattern = /\\/\\.\\//;\n    while (pattern.test(r)) {\n      r = r.replace(pattern, \"/\");\n    }\n\n    // replace ^./ => nothing\n    r = r.replace(/^\\.\\//g, \"\");\n\n    // replace /aa/../ => / (BUT IGNORE /../../)\n    pattern = /\\/(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//;\n    while (pattern.test(r)) {\n      r = r.replace(pattern, \"/\");\n    }\n\n    // replace ^aa/../ => nothing (BUT IGNORE ../../)\n    r = r.replace(/^(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//, \"\");\n    return r;\n  }\n\n  /**\n   * Resolve relative module ids\n   */\n  resolveModule(moduleId) {\n    let result = moduleId;\n    if (!_utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.isAbsolutePath(result)) {\n      if (_utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.startsWith(result, \"./\") || _utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.startsWith(result, \"../\")) {\n        result = ModuleIdResolver._normalizeModuleId(this.fromModulePath + result);\n      }\n    }\n    return result;\n  }\n}\n\n// ------------------------------------------------------------------------\n// Module\nclass Module {\n  constructor(id, strId, dependencies, callback, errorback, moduleIdResolver) {\n    this.id = id;\n    this.strId = strId;\n    this.dependencies = dependencies;\n    this._callback = callback;\n    this._errorback = errorback;\n    this.moduleIdResolver = moduleIdResolver;\n    this.exports = {};\n    this.error = null;\n    this.exportsPassedIn = false;\n    this.unresolvedDependenciesCount = this.dependencies.length;\n    this._isComplete = false;\n  }\n  static _safeInvokeFunction(callback, args) {\n    try {\n      return {\n        returnedValue: callback.apply(_env__WEBPACK_IMPORTED_MODULE_3__.globalVar, args),\n        producedError: null\n      };\n    } catch (e) {\n      return {\n        returnedValue: null,\n        producedError: e\n      };\n    }\n  }\n  static _invokeFactory(config, strModuleId, callback, dependenciesValues) {\n    if (!config.shouldInvokeFactory(strModuleId)) {\n      return {\n        returnedValue: null,\n        producedError: null\n      };\n    }\n    if (config.shouldCatchError()) {\n      return this._safeInvokeFunction(callback, dependenciesValues);\n    }\n    return {\n      returnedValue: callback.apply(_env__WEBPACK_IMPORTED_MODULE_3__.globalVar, dependenciesValues),\n      producedError: null\n    };\n  }\n  complete(recorder, config, dependenciesValues, inversedependenciesProvider) {\n    this._isComplete = true;\n    let producedError = null;\n    if (this._callback) {\n      if (typeof this._callback === \"function\") {\n        recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.BeginInvokeFactory, this.strId);\n        let r = Module._invokeFactory(config, this.strId, this._callback, dependenciesValues);\n        producedError = r.producedError;\n        recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.EndInvokeFactory, this.strId);\n        if (!producedError && typeof r.returnedValue !== \"undefined\" && (!this.exportsPassedIn || _utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.isEmpty(this.exports))) {\n          this.exports = r.returnedValue;\n        }\n      } else {\n        this.exports = this._callback;\n      }\n    }\n    if (producedError) {\n      let err = (0,_configuration__WEBPACK_IMPORTED_MODULE_0__.ensureError)(producedError);\n      err.phase = \"factory\";\n      err.moduleId = this.strId;\n      err.neededBy = inversedependenciesProvider(this.id);\n      this.error = err;\n      config.onError(err);\n    }\n    this.dependencies = null;\n    this._callback = null;\n    this._errorback = null;\n    this.moduleIdResolver = null;\n  }\n\n  /**\n   * One of the direct dependencies or a transitive dependency has failed to load.\n   */\n  onDependencyError(err) {\n    this._isComplete = true;\n    this.error = err;\n    if (this._errorback) {\n      this._errorback(err);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Is the current module complete?\n   */\n  isComplete() {\n    return this._isComplete;\n  }\n}\n\n// ------------------------------------------------------------------------\n// ModuleManager\n\nlet ModuleId = /*#__PURE__*/function (ModuleId) {\n  ModuleId[ModuleId[\"EXPORTS\"] = 0] = \"EXPORTS\";\n  ModuleId[ModuleId[\"MODULE\"] = 1] = \"MODULE\";\n  ModuleId[ModuleId[\"REQUIRE\"] = 2] = \"REQUIRE\";\n  return ModuleId;\n}({});\nclass ModuleIdProvider {\n  constructor() {\n    this._nextId = 0;\n    this._strModuleIdToIntModuleId = new Map();\n    this._intModuleIdToStrModuleId = [];\n\n    // Ensure values 0, 1, 2 are assigned accordingly with ModuleId\n    this.getModuleId(\"exports\");\n    this.getModuleId(\"module\");\n    this.getModuleId(\"require\");\n  }\n  getMaxModuleId() {\n    return this._nextId;\n  }\n  getModuleId(strModuleId) {\n    let id = this._strModuleIdToIntModuleId.get(strModuleId);\n    if (typeof id === \"undefined\") {\n      id = this._nextId++;\n      this._strModuleIdToIntModuleId.set(strModuleId, id);\n      this._intModuleIdToStrModuleId[id] = strModuleId;\n    }\n    return id;\n  }\n  getStrModuleId(moduleId) {\n    return this._intModuleIdToStrModuleId[moduleId];\n  }\n}\nclass RegularDependency {\n  static EXPORTS = new RegularDependency(ModuleId.EXPORTS);\n  static MODULE = new RegularDependency(ModuleId.MODULE);\n  static REQUIRE = new RegularDependency(ModuleId.REQUIRE);\n  constructor(id) {\n    this.id = id;\n  }\n}\nclass PluginDependency {\n  constructor(id, pluginId, pluginParam) {\n    this.id = id;\n    this.pluginId = pluginId;\n    this.pluginParam = pluginParam;\n  }\n}\nclass ModuleManager {\n  /**\n   * map of module id => module.\n   * If a module is found in _modules, its code has been loaded, but\n   * not necessary all its dependencies have been resolved\n   */\n\n  /**\n   * Set of module ids => true\n   * If a module is found in _knownModules, a call has been made\n   * to the scriptLoader to load its code or a call will be made\n   * This is mainly used as a flag to not try loading the same module twice\n   */\n\n  /**\n   * map of module id => array [module id]\n   */\n\n  /**\n   * Hash map of module id => array [ { moduleId, pluginParam } ]\n   */\n\n  /**\n   * current annonymous received define call, but not yet processed\n   */\n\n  constructor(env, scriptLoader, defineFunc, requireFunc) {\n    let loaderAvailableTimestamp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    this._env = env;\n    this._scriptLoader = scriptLoader;\n    this._loaderAvailableTimestamp = loaderAvailableTimestamp;\n    this._defineFunc = defineFunc;\n    this._requireFunc = requireFunc;\n    this._moduleIdProvider = new ModuleIdProvider();\n    this._config = new _configuration__WEBPACK_IMPORTED_MODULE_0__.Configuration(this._env);\n    this._hasDependencyCycle = false;\n    this._modules2 = [];\n    this._knownModules2 = [];\n    this._inverseDependencies2 = [];\n    this._inversePluginDependencies2 = new Map();\n    this._currentAnonymousDefineCall = null;\n    this._recorder = null;\n    this._buildInfoPath = [];\n    this._buildInfoDefineStack = [];\n    this._buildInfoDependencies = [];\n    this._requireFunc.moduleManager = this;\n  }\n  reset() {\n    return new ModuleManager(this._env, this._scriptLoader, this._defineFunc, this._requireFunc, this._loaderAvailableTimestamp);\n  }\n  getGlobalAMDDefineFunc() {\n    return this._defineFunc;\n  }\n  getGlobalAMDRequireFunc() {\n    return this._requireFunc;\n  }\n  static _findRelevantLocationInStack(needle, stack) {\n    let normalize = str => str.replace(/\\\\/g, \"/\");\n    let normalizedPath = normalize(needle);\n    let stackPieces = stack.split(/\\n/);\n    for (let i = 0; i < stackPieces.length; i++) {\n      let m = stackPieces[i].match(/(.*):(\\d+):(\\d+)\\)?$/);\n      if (m) {\n        let stackPath = m[1];\n        let stackLine = m[2];\n        let stackColumn = m[3];\n        let trimPathOffset = Math.max(stackPath.lastIndexOf(\" \") + 1, stackPath.lastIndexOf(\"(\") + 1);\n        stackPath = stackPath.substr(trimPathOffset);\n        stackPath = normalize(stackPath);\n        if (stackPath === normalizedPath) {\n          let r = {\n            line: parseInt(stackLine, 10),\n            col: parseInt(stackColumn, 10)\n          };\n          if (r.line === 1) {\n            r.col -= \"(function (require, define, __filename, __dirname) { \".length;\n          }\n          return r;\n        }\n      }\n    }\n    throw new Error(\"Could not correlate define call site for needle \" + needle);\n  }\n  getBuildInfo() {\n    if (!this._config.isBuild()) {\n      return null;\n    }\n    let result = [],\n      resultLen = 0;\n    for (let i = 0, len = this._modules2.length; i < len; i++) {\n      let m = this._modules2[i];\n      if (!m) {\n        continue;\n      }\n      let location = this._buildInfoPath[m.id] || null;\n      let defineStack = this._buildInfoDefineStack[m.id] || null;\n      let dependencies = this._buildInfoDependencies[m.id];\n      result[resultLen++] = {\n        id: m.strId,\n        path: location,\n        defineLocation: location && defineStack ? ModuleManager._findRelevantLocationInStack(location, defineStack) : null,\n        dependencies: dependencies,\n        shim: null,\n        exports: m.exports\n      };\n    }\n    return result;\n  }\n  getRecorder() {\n    if (!this._recorder) {\n      if (this._config.shouldRecordStats()) {\n        this._recorder = new _loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventRecorder(this._loaderAvailableTimestamp);\n      } else {\n        this._recorder = _loaderEvents__WEBPACK_IMPORTED_MODULE_1__.NullLoaderEventRecorder.INSTANCE;\n      }\n    }\n    return this._recorder;\n  }\n  getLoaderEvents() {\n    return this.getRecorder().getEvents();\n  }\n\n  /**\n   * Defines an anonymous module (without an id). Its name will be resolved as we receive a callback from the scriptLoader.\n   * @param dependencies @see defineModule\n   * @param callback @see defineModule\n   */\n  enqueueDefineAnonymousModule(dependencies, callback) {\n    if (this._currentAnonymousDefineCall !== null) {\n      throw new Error(\"Can only have one anonymous define call per script file\");\n    }\n    let stack = null;\n    if (this._config.isBuild()) {\n      stack = new Error(\"StackLocation\").stack || null;\n    }\n    this._currentAnonymousDefineCall = {\n      stack: stack,\n      dependencies: dependencies,\n      callback: callback\n    };\n  }\n\n  /**\n   * Creates a module and stores it in _modules. The manager will immediately begin resolving its dependencies.\n   * @param strModuleId An unique and absolute id of the module. This must not collide with another module's id\n   * @param dependencies An array with the dependencies of the module. Special keys are: \"require\", \"exports\" and \"module\"\n   * @param callback if callback is a function, it will be called with the resolved dependencies. if callback is an object, it will be considered as the exports of the module.\n   */\n  defineModule(strModuleId, dependencies, callback, errorback, stack) {\n    let moduleIdResolver = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new ModuleIdResolver(strModuleId);\n    let moduleId = this._moduleIdProvider.getModuleId(strModuleId);\n    if (this._modules2[moduleId]) {\n      if (!this._config.isDuplicateMessageIgnoredFor(strModuleId)) {\n        console.warn(\"Duplicate definition of module '\" + strModuleId + \"'\");\n      }\n      // Super important! Completely ignore duplicate module definition\n      return;\n    }\n    let m = new Module(moduleId, strModuleId, this._normalizeDependencies(dependencies, moduleIdResolver), callback, errorback, moduleIdResolver);\n    this._modules2[moduleId] = m;\n    if (this._config.isBuild()) {\n      this._buildInfoDefineStack[moduleId] = stack;\n      this._buildInfoDependencies[moduleId] = (m.dependencies || []).map(dep => this._moduleIdProvider.getStrModuleId(dep.id));\n    }\n\n    // Resolving of dependencies is immediate (not in a timeout). If there's a need to support a packer that concatenates in an\n    // unordered manner, in order to finish processing the file, execute the following method in a timeout\n    this._resolve(m);\n  }\n  _normalizeDependency(dependency, moduleIdResolver) {\n    if (dependency === \"exports\") {\n      return RegularDependency.EXPORTS;\n    }\n    if (dependency === \"module\") {\n      return RegularDependency.MODULE;\n    }\n    if (dependency === \"require\") {\n      return RegularDependency.REQUIRE;\n    }\n    // Normalize dependency and then request it from the manager\n    let bangIndex = dependency.indexOf(\"!\");\n    if (bangIndex >= 0) {\n      let strPluginId = moduleIdResolver.resolveModule(dependency.substr(0, bangIndex));\n      let pluginParam = moduleIdResolver.resolveModule(dependency.substr(bangIndex + 1));\n      let dependencyId = this._moduleIdProvider.getModuleId(strPluginId + \"!\" + pluginParam);\n      let pluginId = this._moduleIdProvider.getModuleId(strPluginId);\n      return new PluginDependency(dependencyId, pluginId, pluginParam);\n    }\n    return new RegularDependency(this._moduleIdProvider.getModuleId(moduleIdResolver.resolveModule(dependency)));\n  }\n  _normalizeDependencies(dependencies, moduleIdResolver) {\n    let result = [],\n      resultLen = 0;\n    for (let i = 0, len = dependencies.length; i < len; i++) {\n      result[resultLen++] = this._normalizeDependency(dependencies[i], moduleIdResolver);\n    }\n    return result;\n  }\n  _relativeRequire(moduleIdResolver, dependencies, callback, errorback) {\n    if (typeof dependencies === \"string\") {\n      return this.synchronousRequire(dependencies, moduleIdResolver);\n    }\n    this.defineModule(_utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.generateAnonymousModule(), dependencies, callback, errorback, null, moduleIdResolver);\n  }\n\n  /**\n   * Require synchronously a module by its absolute id. If the module is not loaded, an exception will be thrown.\n   * @param id The unique and absolute id of the required module\n   * @return The exports of module 'id'\n   */\n  synchronousRequire(_strModuleId) {\n    let moduleIdResolver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new ModuleIdResolver(_strModuleId);\n    let dependency = this._normalizeDependency(_strModuleId, moduleIdResolver);\n    let m = this._modules2[dependency.id];\n    if (!m) {\n      throw new Error(\"Check dependency list! Synchronous require cannot resolve module '\" + _strModuleId + \"'. This is the first mention of this module!\");\n    }\n    if (!m.isComplete()) {\n      throw new Error(\"Check dependency list! Synchronous require cannot resolve module '\" + _strModuleId + \"'. This module has not been resolved completely yet.\");\n    }\n    if (m.error) {\n      throw m.error;\n    }\n    return m.exports;\n  }\n  configure(params, shouldOverwrite) {\n    let oldShouldRecordStats = this._config.shouldRecordStats();\n    if (shouldOverwrite) {\n      this._config = new _configuration__WEBPACK_IMPORTED_MODULE_0__.Configuration(this._env, params);\n    } else {\n      this._config = this._config.cloneAndMerge(params);\n    }\n    if (this._config.shouldRecordStats() && !oldShouldRecordStats) {\n      this._recorder = null;\n    }\n  }\n  getConfig() {\n    return this._config;\n  }\n\n  /**\n   * Callback from the scriptLoader when a module has been loaded.\n   * This means its code is available and has been executed.\n   */\n  _onLoad(moduleId) {\n    if (this._currentAnonymousDefineCall !== null) {\n      let defineCall = this._currentAnonymousDefineCall;\n      this._currentAnonymousDefineCall = null;\n\n      // Hit an anonymous define call\n      this.defineModule(this._moduleIdProvider.getStrModuleId(moduleId), defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n    }\n  }\n  _createLoadError(moduleId, _err) {\n    let strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);\n    let neededBy = (this._inverseDependencies2[moduleId] || []).map(intModuleId => this._moduleIdProvider.getStrModuleId(intModuleId));\n    const err = (0,_configuration__WEBPACK_IMPORTED_MODULE_0__.ensureError)(_err);\n    err.phase = \"loading\";\n    err.moduleId = strModuleId;\n    err.neededBy = neededBy;\n    return err;\n  }\n\n  /**\n   * Callback from the scriptLoader when a module hasn't been loaded.\n   * This means that the script was not found (e.g. 404) or there was an error in the script.\n   */\n  _onLoadError(moduleId, err) {\n    const error = this._createLoadError(moduleId, err);\n    if (!this._modules2[moduleId]) {\n      this._modules2[moduleId] = new Module(moduleId, this._moduleIdProvider.getStrModuleId(moduleId), [], () => {}, null, null);\n    }\n\n    // Find any 'local' error handlers, walk the entire chain of inverse dependencies if necessary.\n    let seenModuleId = [];\n    for (let i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {\n      seenModuleId[i] = false;\n    }\n    let someoneNotified = false;\n    let queue = [];\n    queue.push(moduleId);\n    seenModuleId[moduleId] = true;\n    while (queue.length > 0) {\n      let queueElement = queue.shift();\n      let m = this._modules2[queueElement];\n      if (m) {\n        someoneNotified = m.onDependencyError(error) || someoneNotified;\n      }\n      let inverseDeps = this._inverseDependencies2[queueElement];\n      if (inverseDeps) {\n        for (let i = 0, len = inverseDeps.length; i < len; i++) {\n          let inverseDep = inverseDeps[i];\n          if (!seenModuleId[inverseDep]) {\n            queue.push(inverseDep);\n            seenModuleId[inverseDep] = true;\n          }\n        }\n      }\n    }\n    if (!someoneNotified) {\n      this._config.onError(error);\n    }\n  }\n\n  /**\n   * Walks (recursively) the dependencies of 'from' in search of 'to'.\n   * Returns true if there is such a path or false otherwise.\n   * @param from Module id to start at\n   * @param to Module id to look for\n   */\n  _hasDependencyPath(fromId, toId) {\n    let from = this._modules2[fromId];\n    if (!from) {\n      return false;\n    }\n    let inQueue = [];\n    for (let i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {\n      inQueue[i] = false;\n    }\n    let queue = [];\n\n    // Insert 'from' in queue\n    queue.push(from);\n    inQueue[fromId] = true;\n    while (queue.length > 0) {\n      // Pop first inserted element of queue\n      let element = queue.shift();\n      let dependencies = element.dependencies;\n      if (dependencies) {\n        // Walk the element's dependencies\n        for (let i = 0, len = dependencies.length; i < len; i++) {\n          let dependency = dependencies[i];\n          if (dependency.id === toId) {\n            // There is a path to 'to'\n            return true;\n          }\n          let dependencyModule = this._modules2[dependency.id];\n          if (dependencyModule && !inQueue[dependency.id]) {\n            // Insert 'dependency' in queue\n            inQueue[dependency.id] = true;\n            queue.push(dependencyModule);\n          }\n        }\n      }\n    }\n\n    // There is no path to 'to'\n    return false;\n  }\n\n  /**\n   * Walks (recursively) the dependencies of 'from' in search of 'to'.\n   * Returns cycle as array.\n   * @param from Module id to start at\n   * @param to Module id to look for\n   */\n  _findCyclePath(fromId, toId, depth) {\n    if (fromId === toId || depth === 50) {\n      return [fromId];\n    }\n    let from = this._modules2[fromId];\n    if (!from) {\n      return null;\n    }\n\n    // Walk the element's dependencies\n    let dependencies = from.dependencies;\n    if (dependencies) {\n      for (let i = 0, len = dependencies.length; i < len; i++) {\n        let path = this._findCyclePath(dependencies[i].id, toId, depth + 1);\n        if (path !== null) {\n          path.push(fromId);\n          return path;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Create the local 'require' that is passed into modules\n   */\n  _createRequire(moduleIdResolver) {\n    var _this = this;\n    let result = (dependencies, callback, errorback) => {\n      return this._relativeRequire(moduleIdResolver, dependencies, callback, errorback);\n    };\n    result.toUrl = id => {\n      return this._config.requireToUrl(moduleIdResolver.resolveModule(id));\n    };\n    result.getStats = () => {\n      return this.getLoaderEvents();\n    };\n    result.hasDependencyCycle = () => {\n      return this._hasDependencyCycle;\n    };\n    result.config = function (params) {\n      let shouldOverwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      _this.configure(params, shouldOverwrite);\n    };\n    result.__$__nodeRequire = _env__WEBPACK_IMPORTED_MODULE_3__.globalVar.nodeRequire;\n    return result;\n  }\n  _loadModule(moduleId) {\n    if (this._modules2[moduleId] || this._knownModules2[moduleId]) {\n      // known module\n      return;\n    }\n    this._knownModules2[moduleId] = true;\n    let strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);\n    let paths = this._config.moduleIdToPaths(strModuleId);\n    let scopedPackageRegex = /^@[^\\/]+\\/[^\\/]+$/; // matches @scope/package-name\n    if (this._env.isNode && (strModuleId.indexOf(\"/\") === -1 || scopedPackageRegex.test(strModuleId))) {\n      paths.push(\"node|\" + strModuleId);\n    }\n    let lastPathIndex = -1;\n    let loadNextPath = err => {\n      lastPathIndex++;\n      if (lastPathIndex >= paths.length) {\n        // No more paths to try\n        this._onLoadError(moduleId, err);\n      } else {\n        let currentPath = paths[lastPathIndex];\n        let recorder = this.getRecorder();\n        if (this._config.isBuild() && currentPath === \"empty:\") {\n          this._buildInfoPath[moduleId] = currentPath;\n          this.defineModule(this._moduleIdProvider.getStrModuleId(moduleId), [], null, null, null);\n          this._onLoad(moduleId);\n          return;\n        }\n        recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.BeginLoadingScript, currentPath);\n        this._scriptLoader.load(this, currentPath, () => {\n          if (this._config.isBuild()) {\n            this._buildInfoPath[moduleId] = currentPath;\n          }\n          recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.EndLoadingScriptOK, currentPath);\n          this._onLoad(moduleId);\n        }, err => {\n          recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.EndLoadingScriptError, currentPath);\n          loadNextPath(err);\n        });\n      }\n    };\n    loadNextPath(null);\n  }\n\n  /**\n   * Resolve a plugin dependency with the plugin loaded & complete\n   * @param module The module that has this dependency\n   * @param pluginDependency The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n   * @param plugin The plugin (what the plugin exports)\n   */\n  _loadPluginDependency(plugin, pluginDependency) {\n    if (this._modules2[pluginDependency.id] || this._knownModules2[pluginDependency.id]) {\n      // known module\n      return;\n    }\n    this._knownModules2[pluginDependency.id] = true;\n\n    // Delegate the loading of the resource to the plugin\n    let load = value => {\n      this.defineModule(this._moduleIdProvider.getStrModuleId(pluginDependency.id), [], value, null, null);\n    };\n    load.error = err => {\n      this._config.onError(this._createLoadError(pluginDependency.id, err));\n    };\n    plugin.load(pluginDependency.pluginParam, this._createRequire(ModuleIdResolver.ROOT), load, this._config.getOptionsLiteral());\n  }\n\n  /**\n   * Examine the dependencies of module 'module' and resolve them as needed.\n   */\n  _resolve(module) {\n    let dependencies = module.dependencies;\n    if (dependencies) {\n      for (let i = 0, len = dependencies.length; i < len; i++) {\n        let dependency = dependencies[i];\n        if (dependency === RegularDependency.EXPORTS) {\n          module.exportsPassedIn = true;\n          module.unresolvedDependenciesCount--;\n          continue;\n        }\n        if (dependency === RegularDependency.MODULE) {\n          module.unresolvedDependenciesCount--;\n          continue;\n        }\n        if (dependency === RegularDependency.REQUIRE) {\n          module.unresolvedDependenciesCount--;\n          continue;\n        }\n        let dependencyModule = this._modules2[dependency.id];\n        if (dependencyModule && dependencyModule.isComplete()) {\n          if (dependencyModule.error) {\n            module.onDependencyError(dependencyModule.error);\n            return;\n          }\n          module.unresolvedDependenciesCount--;\n          continue;\n        }\n        if (this._hasDependencyPath(dependency.id, module.id)) {\n          this._hasDependencyCycle = true;\n          console.warn(\"There is a dependency cycle between '\" + this._moduleIdProvider.getStrModuleId(dependency.id) + \"' and '\" + this._moduleIdProvider.getStrModuleId(module.id) + \"'. The cyclic path follows:\");\n          let cyclePath = this._findCyclePath(dependency.id, module.id, 0) || [];\n          cyclePath.reverse();\n          cyclePath.push(dependency.id);\n          console.warn(cyclePath.map(id => this._moduleIdProvider.getStrModuleId(id)).join(\" => \\n\"));\n\n          // Break the cycle\n          module.unresolvedDependenciesCount--;\n          continue;\n        }\n\n        // record inverse dependency\n        this._inverseDependencies2[dependency.id] = this._inverseDependencies2[dependency.id] || [];\n        this._inverseDependencies2[dependency.id].push(module.id);\n        if (dependency instanceof PluginDependency) {\n          let plugin = this._modules2[dependency.pluginId];\n          if (plugin && plugin.isComplete()) {\n            this._loadPluginDependency(plugin.exports, dependency);\n            continue;\n          }\n\n          // Record dependency for when the plugin gets loaded\n          let inversePluginDeps = this._inversePluginDependencies2.get(dependency.pluginId);\n          if (!inversePluginDeps) {\n            inversePluginDeps = [];\n            this._inversePluginDependencies2.set(dependency.pluginId, inversePluginDeps);\n          }\n          inversePluginDeps.push(dependency);\n          this._loadModule(dependency.pluginId);\n          continue;\n        }\n        this._loadModule(dependency.id);\n      }\n    }\n    if (module.unresolvedDependenciesCount === 0) {\n      this._onModuleComplete(module);\n    }\n  }\n  _onModuleComplete(module) {\n    let recorder = this.getRecorder();\n    if (module.isComplete()) {\n      // already done\n      return;\n    }\n    let dependencies = module.dependencies;\n    let dependenciesValues = [];\n    if (dependencies) {\n      for (let i = 0, len = dependencies.length; i < len; i++) {\n        let dependency = dependencies[i];\n        if (dependency === RegularDependency.EXPORTS) {\n          dependenciesValues[i] = module.exports;\n          continue;\n        }\n        if (dependency === RegularDependency.MODULE) {\n          dependenciesValues[i] = {\n            id: module.strId,\n            config: () => {\n              return this._config.getConfigForModule(module.strId);\n            }\n          };\n          continue;\n        }\n        if (dependency === RegularDependency.REQUIRE) {\n          dependenciesValues[i] = this._createRequire(module.moduleIdResolver);\n          continue;\n        }\n        let dependencyModule = this._modules2[dependency.id];\n        if (dependencyModule) {\n          dependenciesValues[i] = dependencyModule.exports;\n          continue;\n        }\n        dependenciesValues[i] = null;\n      }\n    }\n    const inversedependenciesProvider = moduleId => {\n      return (this._inverseDependencies2[moduleId] || []).map(intModuleId => this._moduleIdProvider.getStrModuleId(intModuleId));\n    };\n    module.complete(recorder, this._config, dependenciesValues, inversedependenciesProvider);\n\n    // Fetch and clear inverse dependencies\n    let inverseDeps = this._inverseDependencies2[module.id];\n    this._inverseDependencies2[module.id] = null;\n    if (inverseDeps) {\n      // Resolve one inverse dependency at a time, always\n      // on the lookout for a completed module.\n      for (let i = 0, len = inverseDeps.length; i < len; i++) {\n        let inverseDependencyId = inverseDeps[i];\n        let inverseDependency = this._modules2[inverseDependencyId];\n        inverseDependency.unresolvedDependenciesCount--;\n        if (inverseDependency.unresolvedDependenciesCount === 0) {\n          this._onModuleComplete(inverseDependency);\n        }\n      }\n    }\n    let inversePluginDeps = this._inversePluginDependencies2.get(module.id);\n    if (inversePluginDeps) {\n      // This module is used as a plugin at least once\n      // Fetch and clear these inverse plugin dependencies\n      this._inversePluginDependencies2.delete(module.id);\n\n      // Resolve plugin dependencies one at a time\n      for (let i = 0, len = inversePluginDeps.length; i < len; i++) {\n        this._loadPluginDependency(module.exports, inversePluginDeps[i]);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/moduleManager.ts?");

/***/ }),

/***/ "./src/core/scriptLoader.ts":
/*!**********************************!*\
  !*** ./src/core/scriptLoader.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScriptLoader: () => (/* binding */ createScriptLoader),\n/* harmony export */   ensureRecordedNodeRequire: () => (/* binding */ ensureRecordedNodeRequire)\n/* harmony export */ });\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ \"./src/core/env.ts\");\n/* harmony import */ var _loaderEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loaderEvents */ \"./src/core/loaderEvents.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/core/utils.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n// ------------------------------------------------------------------------\n// IScriptLoader(s)\n\n// class LazyScriptLoader implements IScriptLoader {\n// \tconstructor() {\n\n// \t}\n\n// \tpublic load(moduleManager: IModuleManager, scriptPath: string, loadCallback: () => void, errorCallback: (err: any) => void): void {\n\n// \t}\n// }\n\nconst isCrossOriginFn = scriptSrc => {\n  return /^((http:)|(https:)|(file:))/.test(scriptSrc) && scriptSrc.substring(0, self.origin.length) !== self.origin;\n};\n\n/**\n * Load `scriptSrc` only once (avoid multiple <script> tags)\n */\nclass OnlyOnceScriptLoader {\n  constructor(env) {\n    this._env = env;\n    this._scriptLoader = null;\n    this._callbackMap = {};\n  }\n  load(moduleManager, scriptSrc, callback, errorback) {\n    if (!this._scriptLoader) {\n      if (this._env.isWebWorker) {\n        this._scriptLoader = new WorkerScriptLoader();\n      } else if (this._env.isElectronRenderer) {\n        const {\n          preferScriptTags\n        } = moduleManager.getConfig().getOptionsLiteral();\n        if (preferScriptTags) {\n          this._scriptLoader = new BrowserScriptLoader();\n        } else {\n          this._scriptLoader = new NodeScriptLoader(this._env);\n        }\n      } else if (this._env.isNode) {\n        this._scriptLoader = new NodeScriptLoader(this._env);\n      } else {\n        this._scriptLoader = new BrowserScriptLoader();\n      }\n    }\n    let scriptCallbacks = {\n      callback: callback,\n      errorback: errorback\n    };\n    if (this._callbackMap.hasOwnProperty(scriptSrc)) {\n      this._callbackMap[scriptSrc].push(scriptCallbacks);\n      return;\n    }\n    this._callbackMap[scriptSrc] = [scriptCallbacks];\n    this._scriptLoader.load(moduleManager, scriptSrc, () => this.triggerCallback(scriptSrc), err => this.triggerErrorback(scriptSrc, err));\n  }\n  triggerCallback(scriptSrc) {\n    let scriptCallbacks = this._callbackMap[scriptSrc];\n    delete this._callbackMap[scriptSrc];\n    for (let i = 0; i < scriptCallbacks.length; i++) {\n      scriptCallbacks[i].callback();\n    }\n  }\n  triggerErrorback(scriptSrc, err) {\n    let scriptCallbacks = this._callbackMap[scriptSrc];\n    delete this._callbackMap[scriptSrc];\n    for (let i = 0; i < scriptCallbacks.length; i++) {\n      scriptCallbacks[i].errorback(err);\n    }\n  }\n}\nclass BrowserScriptLoader {\n  _cachedCanUseEval = null;\n  _canUseEval(moduleManager) {\n    if (this._cachedCanUseEval === null) {\n      this._cachedCanUseEval = canUseEval(moduleManager);\n    }\n    return this._cachedCanUseEval;\n  }\n  /**\n   * Attach load / error listeners to a script element and remove them when either one has fired.\n   * Implemented for browsers supporting HTML5 standard 'load' and 'error' events.\n   */\n  attachListeners(script, callback, errorback) {\n    let unbind = () => {\n      script.removeEventListener(\"load\", loadEventListener);\n      script.removeEventListener(\"error\", errorEventListener);\n    };\n    let loadEventListener = e => {\n      unbind();\n      callback();\n    };\n    let errorEventListener = e => {\n      unbind();\n      errorback(e);\n    };\n    script.addEventListener(\"load\", loadEventListener);\n    script.addEventListener(\"error\", errorEventListener);\n  }\n  async load(moduleManager, scriptSrc, callback, errorback) {\n    if (/^node\\|/.test(scriptSrc)) {\n      let opts = moduleManager.getConfig().getOptionsLiteral();\n      let nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), opts.nodeRequire || _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.nodeRequire);\n      let pieces = scriptSrc.split(\"|\");\n      let moduleExports = null;\n      try {\n        moduleExports = nodeRequire(pieces[1]);\n      } catch (err) {\n        errorback(new Error(`${err.message} &-1 ${scriptSrc} & ${pieces.join(\",\")}`));\n        return;\n      }\n      moduleManager.enqueueDefineAnonymousModule([], () => moduleExports);\n      callback();\n    } else {\n      const isCrossOrigin = isCrossOriginFn(scriptSrc);\n      const {\n        trustedTypesPolicy\n      } = moduleManager.getConfig().getOptionsLiteral();\n      let text = undefined;\n      if (this._canUseEval(moduleManager)) {\n        const uniqueID = _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.getUniqueID();\n        // use `fetch` if possible because `importScripts`\n        // is synchronous and can lead to deadlocks on Safari\n        text = await fetch(scriptSrc).then(response => {\n          if (response.status !== 200) {\n            throw new Error(response.statusText);\n          }\n          return response.text();\n        }).then(text => {\n          return `(function(define) {\\n${text}\\n})(window[\"${uniqueID}\"].define);\\nwindow.__icubeResolveModule__({type:\"__icube_module_loaded__\", loaderID: \"${uniqueID}\", origin: \"${scriptSrc}\"  });\\n//# sourceURL=${scriptSrc}`;\n        }).catch(err => {\n          throw err;\n        }).then(undefined, errorback);\n      }\n      let script = document.createElement(\"script\");\n      script.setAttribute(\"async\", \"async\");\n      script.setAttribute(\"type\", \"text/javascript\");\n\n      // if (\n      //   scriptSrc ===\n      //   \"http://localhost:9888/oss-dev/static/out/vs/workbench/workbench.web.main.js\"\n      // ) {\n      //   debugger;\n      // }\n\n      if (!text) {\n        this.attachListeners(script, callback, errorback);\n      }\n      let originScriptSrc = scriptSrc;\n      if (trustedTypesPolicy) {\n        scriptSrc = trustedTypesPolicy.createScriptURL(scriptSrc);\n      }\n      if (text) {\n        script.text = text;\n        window.__icubeResolveModule__ = function (payload) {\n          if (payload?.type === \"__icube_module_loaded__\") {\n            const {\n              loaderID,\n              origin\n            } = payload;\n            if (origin === originScriptSrc && loaderID === _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.getUniqueID()) {\n              callback();\n            }\n          }\n        };\n      } else {\n        script.setAttribute(\"src\", scriptSrc);\n      }\n\n      // Propagate CSP nonce to dynamically created script tag.\n      const {\n        cspNonce\n      } = moduleManager.getConfig().getOptionsLiteral();\n      if (cspNonce) {\n        script.setAttribute(\"nonce\", cspNonce);\n      }\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\n    }\n  }\n}\nfunction canUseEval(moduleManager) {\n  const {\n    trustedTypesPolicy\n  } = moduleManager.getConfig().getOptionsLiteral();\n  try {\n    const func = trustedTypesPolicy ? self.eval(trustedTypesPolicy.createScript(\"\", \"true\")) : new Function(\"true\"); // CodeQL [SM01632] the loader is responsible with loading code, fetch + eval is used on the web worker instead of importScripts if possible because importScripts is synchronous and we observed deadlocks on Safari\n\n    func.call(self);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nclass WorkerScriptLoader {\n  _cachedCanUseEval = null;\n  _canUseEval(moduleManager) {\n    if (this._cachedCanUseEval === null) {\n      this._cachedCanUseEval = canUseEval(moduleManager);\n    }\n    return this._cachedCanUseEval;\n  }\n  load(moduleManager, scriptSrc, callback, errorback) {\n    if (/^node\\|/.test(scriptSrc)) {\n      const opts = moduleManager.getConfig().getOptionsLiteral();\n      const nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), opts.nodeRequire || _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.nodeRequire);\n      const pieces = scriptSrc.split(\"|\");\n      let moduleExports = null;\n      try {\n        moduleExports = nodeRequire(pieces[1]);\n      } catch (err) {\n        const newErr = new Error(`${err.message} &-2 ${scriptSrc} & ${pieces.join(\",\")}`);\n        errorback(newErr);\n        return;\n      }\n      moduleManager.enqueueDefineAnonymousModule([], function () {\n        return moduleExports;\n      });\n      callback();\n    } else {\n      const {\n        trustedTypesPolicy\n      } = moduleManager.getConfig().getOptionsLiteral();\n      const isCrossOrigin = isCrossOriginFn(scriptSrc);\n      if (!isCrossOrigin && this._canUseEval(moduleManager)) {\n        // use `fetch` if possible because `importScripts`\n        // is synchronous and can lead to deadlocks on Safari\n        fetch(scriptSrc).then(response => {\n          if (response.status !== 200) {\n            throw new Error(response.statusText);\n          }\n          return response.text();\n        }).then(text => {\n          text = `${text}\\n//# sourceURL=${scriptSrc}`;\n          const func = trustedTypesPolicy ? self.eval(trustedTypesPolicy.createScript(\"\", text)) : new Function(text); // CodeQL [SM01632] the loader is responsible with loading code, fetch + eval is used on the web worker instead of importScripts if possible because importScripts is synchronous and we observed deadlocks on Safari\n          func.call(self);\n          callback();\n        }).then(undefined, errorback);\n        return;\n      }\n      try {\n        if (trustedTypesPolicy) {\n          scriptSrc = trustedTypesPolicy.createScriptURL(scriptSrc);\n        }\n        importScripts(scriptSrc);\n        callback();\n      } catch (e) {\n        errorback(e);\n      }\n    }\n  }\n}\nclass NodeScriptLoader {\n  static _BOM = 0xfeff;\n  static _PREFIX = \"(function (require, define, __filename, __dirname) { \";\n  static _SUFFIX = \"\\n});\";\n  constructor(env) {\n    this._env = env;\n    this._didInitialize = false;\n    this._didPatchNodeRequire = false;\n  }\n  _init(nodeRequire) {\n    if (this._didInitialize) {\n      return;\n    }\n    this._didInitialize = true;\n\n    // capture node modules\n    this._fs = nodeRequire(\"fs\");\n    this._vm = nodeRequire(\"vm\");\n    this._path = nodeRequire(\"path\");\n    this._crypto = nodeRequire(\"crypto\");\n  }\n\n  // patch require-function of nodejs such that we can manually create a script\n  // from cached data. this is done by overriding the `Module._compile` function\n  _initNodeRequire(nodeRequire, moduleManager) {\n    // It is important to check for `nodeCachedData` first and then set `_didPatchNodeRequire`.\n    // That's because `nodeCachedData` is set _after_ calling this for the first time...\n    const {\n      nodeCachedData\n    } = moduleManager.getConfig().getOptionsLiteral();\n    if (!nodeCachedData) {\n      return;\n    }\n    if (this._didPatchNodeRequire) {\n      return;\n    }\n    this._didPatchNodeRequire = true;\n    const that = this;\n    const Module = nodeRequire(\"module\");\n    function makeRequireFunction(mod) {\n      const Module = mod.constructor;\n      let require = function require(path) {\n        try {\n          return mod.require(path);\n        } finally {\n          // nothing\n        }\n      };\n      require.resolve = function resolve(request, options) {\n        return Module._resolveFilename(request, mod, false, options);\n      };\n      require.resolve.paths = function paths(request) {\n        return Module._resolveLookupPaths(request, mod);\n      };\n      require.main = process.mainModule;\n      require.extensions = Module._extensions;\n      require.cache = Module._cache;\n      return require;\n    }\n    Module.prototype._compile = function (content, filename) {\n      // remove shebang and create wrapper function\n      const scriptSource = Module.wrap(content.replace(/^#!.*/, \"\"));\n\n      // create script\n      const recorder = moduleManager.getRecorder();\n      const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);\n      const options = {\n        filename\n      };\n      let hashData;\n      try {\n        const data = that._fs.readFileSync(cachedDataPath);\n        hashData = data.slice(0, 16);\n        options.cachedData = data.slice(16);\n        recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataFound, cachedDataPath);\n      } catch (_e) {\n        recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataMissed, cachedDataPath);\n      }\n      const script = new that._vm.Script(scriptSource, options);\n      const compileWrapper = script.runInThisContext(options);\n\n      // run script\n      const dirname = that._path.dirname(filename);\n      const require = makeRequireFunction(this);\n      const args = [this.exports, require, this, filename, dirname, process, _env__WEBPACK_IMPORTED_MODULE_0__._commonjsGlobal, Buffer];\n      const result = compileWrapper.apply(this.exports, args);\n\n      // cached data aftermath\n      that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);\n      that._verifyCachedData(script, scriptSource, cachedDataPath, hashData, moduleManager);\n      return result;\n    };\n  }\n  load(moduleManager, scriptSrc, callback, errorback) {\n    const opts = moduleManager.getConfig().getOptionsLiteral();\n    const nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), opts.nodeRequire || _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.nodeRequire);\n    const nodeInstrumenter = opts.nodeInstrumenter || function (c) {\n      return c;\n    };\n    this._init(nodeRequire);\n    this._initNodeRequire(nodeRequire, moduleManager);\n    let recorder = moduleManager.getRecorder();\n    if (/^node\\|/.test(scriptSrc)) {\n      let pieces = scriptSrc.split(\"|\");\n      console.log(\"aaaaa-load-1\", scriptSrc, pieces);\n      let moduleExports = null;\n      try {\n        moduleExports = nodeRequire(pieces[1]);\n      } catch (err) {\n        const newErr = new Error(`${err.message} &-3  ${scriptSrc} & ${pieces.join(\",\")}`);\n        errorback(newErr);\n        return;\n      }\n      moduleManager.enqueueDefineAnonymousModule([], () => moduleExports);\n      callback();\n    } else {\n      scriptSrc = _utils__WEBPACK_IMPORTED_MODULE_2__.Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);\n      const normalizedScriptSrc = this._path.normalize(scriptSrc);\n      const vmScriptPathOrUri = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc);\n      const wantsCachedData = Boolean(opts.nodeCachedData);\n      const cachedDataPath = wantsCachedData ? this._getCachedDataPath(opts.nodeCachedData, scriptSrc) : undefined;\n      this._readSourceAndCachedData(normalizedScriptSrc, cachedDataPath, recorder, (err, data, cachedData, hashData) => {\n        if (err) {\n          errorback(err);\n          return;\n        }\n        let scriptSource;\n        if (data.charCodeAt(0) === NodeScriptLoader._BOM) {\n          scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;\n        } else {\n          scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;\n        }\n        scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc);\n        const scriptOpts = {\n          filename: vmScriptPathOrUri,\n          cachedData\n        };\n        const script = this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);\n        this._handleCachedData(script, scriptSource, cachedDataPath, wantsCachedData && !cachedData, moduleManager);\n        this._verifyCachedData(script, scriptSource, cachedDataPath, hashData, moduleManager);\n      });\n    }\n  }\n  _createAndEvalScript(moduleManager, contents, options, callback, errorback) {\n    const recorder = moduleManager.getRecorder();\n    recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.NodeBeginEvaluatingScript, options.filename);\n    const script = new this._vm.Script(contents, options);\n    const ret = script.runInThisContext(options);\n    const globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();\n    let receivedDefineCall = false;\n    const localDefineFunc = function () {\n      receivedDefineCall = true;\n      return globalDefineFunc.apply(null, arguments);\n    };\n    localDefineFunc.amd = globalDefineFunc.amd;\n    ret.call(_env__WEBPACK_IMPORTED_MODULE_0__.globalVar, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));\n    recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.NodeEndEvaluatingScript, options.filename);\n    if (receivedDefineCall) {\n      callback();\n    } else {\n      errorback(new Error(`Didn't receive define call in ${options.filename}!`));\n    }\n    return script;\n  }\n  _getElectronRendererScriptPathOrUri(path) {\n    if (!this._env.isElectronRenderer) {\n      return path;\n    }\n    let driveLetterMatch = path.match(/^([a-z])\\:(.*)/i);\n    if (driveLetterMatch) {\n      // windows\n      return `file:///${(driveLetterMatch[1].toUpperCase() + \":\" + driveLetterMatch[2]).replace(/\\\\/g, \"/\")}`;\n    } else {\n      // nix\n      return `file://${path}`;\n    }\n  }\n  _getCachedDataPath(config, filename) {\n    const hash = this._crypto.createHash(\"md5\").update(filename, \"utf8\").update(config.seed, \"utf8\").update(process.arch, \"\").digest(\"hex\");\n    const basename = this._path.basename(filename).replace(/\\.js$/, \"\");\n    return this._path.join(config.path, `${basename}-${hash}.code`);\n  }\n  _handleCachedData(script, scriptSource, cachedDataPath, createCachedData, moduleManager) {\n    if (script.cachedDataRejected) {\n      // cached data got rejected -> delete and re-create\n      this._fs.unlink(cachedDataPath, err => {\n        moduleManager.getRecorder().record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataRejected, cachedDataPath);\n        this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);\n        if (err) {\n          moduleManager.getConfig().onError(err);\n        }\n      });\n    } else if (createCachedData) {\n      // no cached data, but wanted\n      this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);\n    }\n  }\n\n  // Cached data format: | SOURCE_HASH | V8_CACHED_DATA |\n  // -SOURCE_HASH is the md5 hash of the JS source (always 16 bytes)\n  // -V8_CACHED_DATA is what v8 produces\n\n  _createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager) {\n    let timeout = Math.ceil(moduleManager.getConfig().getOptionsLiteral().nodeCachedData.writeDelay * (1 + Math.random()));\n    let lastSize = -1;\n    let iteration = 0;\n    let hashData = undefined;\n    const createLoop = () => {\n      setTimeout(() => {\n        if (!hashData) {\n          hashData = this._crypto.createHash(\"md5\").update(scriptSource, \"utf8\").digest();\n        }\n        const cachedData = script.createCachedData();\n        if (cachedData.length === 0 || cachedData.length === lastSize || iteration >= 5) {\n          // done\n          return;\n        }\n        if (cachedData.length < lastSize) {\n          // less data than before: skip, try again next round\n          createLoop();\n          return;\n        }\n        lastSize = cachedData.length;\n        this._fs.writeFile(cachedDataPath, Buffer.concat([hashData, cachedData]), err => {\n          if (err) {\n            moduleManager.getConfig().onError(err);\n          }\n          moduleManager.getRecorder().record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataCreated, cachedDataPath);\n          createLoop();\n        });\n      }, timeout * 4 ** iteration++);\n    };\n\n    // with some delay (`timeout`) create cached data\n    // and repeat that (with backoff delay) until the\n    // data seems to be not changing anymore\n    createLoop();\n  }\n  _readSourceAndCachedData(sourcePath, cachedDataPath, recorder, callback) {\n    if (!cachedDataPath) {\n      // no cached data case\n      this._fs.readFile(sourcePath, {\n        encoding: \"utf8\"\n      }, callback);\n    } else {\n      // cached data case: read both files in parallel\n      let source = undefined;\n      let cachedData = undefined;\n      let hashData = undefined;\n      let steps = 2;\n      const step = err => {\n        if (err) {\n          callback(err);\n        } else if (--steps === 0) {\n          callback(undefined, source, cachedData, hashData);\n        }\n      };\n      this._fs.readFile(sourcePath, {\n        encoding: \"utf8\"\n      }, (err, data) => {\n        source = data;\n        step(err);\n      });\n      this._fs.readFile(cachedDataPath, (err, data) => {\n        if (!err && data && data.length > 0) {\n          hashData = data.slice(0, 16);\n          cachedData = data.slice(16);\n          recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataFound, cachedDataPath);\n        } else {\n          recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.CachedDataMissed, cachedDataPath);\n        }\n        step(); // ignored: cached data is optional\n      });\n    }\n  }\n  _verifyCachedData(script, scriptSource, cachedDataPath, hashData, moduleManager) {\n    if (!hashData) {\n      // nothing to do\n      return;\n    }\n    if (script.cachedDataRejected) {\n      // invalid anyways\n      return;\n    }\n    setTimeout(() => {\n      // check source hash - the contract is that file paths change when file content\n      // change (e.g use the commit or version id as cache path). this check is\n      // for violations of this contract.\n      const hashDataNow = this._crypto.createHash(\"md5\").update(scriptSource, \"utf8\").digest();\n      if (!hashData.equals(hashDataNow)) {\n        moduleManager.getConfig().onError(new Error(`FAILED TO VERIFY CACHED DATA, deleting stale '${cachedDataPath}' now, but a RESTART IS REQUIRED`));\n        this._fs.unlink(cachedDataPath, err => {\n          if (err) {\n            moduleManager.getConfig().onError(err);\n          }\n        });\n      }\n    }, Math.ceil(5000 * (1 + Math.random())));\n  }\n}\nfunction ensureRecordedNodeRequire(recorder, _nodeRequire) {\n  if (_nodeRequire.__$__isRecorded) {\n    // it is already recorded\n    return _nodeRequire;\n  }\n  const nodeRequire = function nodeRequire(what) {\n    recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.NodeBeginNativeRequire, what);\n    try {\n      return _nodeRequire(what);\n    } catch (err) {\n      throw new Error(`${err.message} &-4 ${what}`);\n    } finally {\n      recorder.record(_loaderEvents__WEBPACK_IMPORTED_MODULE_1__.LoaderEventType.NodeEndNativeRequire, what);\n    }\n  };\n  nodeRequire.__$__isRecorded = true;\n  return nodeRequire;\n}\nfunction createScriptLoader(env) {\n  return new OnlyOnceScriptLoader(env);\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/scriptLoader.ts?");

/***/ }),

/***/ "./src/core/utils.ts":
/*!***************************!*\
  !*** ./src/core/utils.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utilities: () => (/* binding */ Utilities)\n/* harmony export */ });\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ \"./src/core/env.ts\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nclass Utilities {\n  /**\n   * This method does not take care of / vs \\\n   */\n  static fileUriToFilePath(isWindows, uri) {\n    uri = decodeURI(uri).replace(/%23/g, \"#\");\n    if (isWindows) {\n      if (/^file:\\/\\/\\//.test(uri)) {\n        // This is a URI without a hostname => return only the path segment\n        return uri.substr(8);\n      }\n      if (/^file:\\/\\//.test(uri)) {\n        return uri.substr(5);\n      }\n    } else {\n      if (/^file:\\/\\//.test(uri)) {\n        return uri.substr(7);\n      }\n    }\n    // Not sure...\n    return uri;\n  }\n  static startsWith(haystack, needle) {\n    return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;\n  }\n  static endsWith(haystack, needle) {\n    return haystack.length >= needle.length && haystack.substr(haystack.length - needle.length) === needle;\n  }\n\n  // only check for \"?\" before \"#\" to ensure that there is a real Query-String\n  static containsQueryString(url) {\n    return /^[^\\#]*\\?/gi.test(url);\n  }\n\n  /**\n   * Does `url` start with http:// or https:// or file:// or / ?\n   */\n  static isAbsolutePath(url) {\n    return /^((http:\\/\\/)|(https:\\/\\/)|(file:\\/\\/)|(\\/))/.test(url);\n  }\n  static forEachProperty(obj, callback) {\n    if (obj) {\n      let key;\n      for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  static isEmpty(obj) {\n    let isEmpty = true;\n    Utilities.forEachProperty(obj, () => {\n      isEmpty = false;\n    });\n    return isEmpty;\n  }\n  static recursiveClone(obj) {\n    if (!obj || typeof obj !== \"object\" || obj instanceof RegExp) {\n      return obj;\n    }\n    if (!Array.isArray(obj) && Object.getPrototypeOf(obj) !== Object.prototype) {\n      // only clone \"simple\" objects\n      return obj;\n    }\n    let result = Array.isArray(obj) ? [] : {};\n    Utilities.forEachProperty(obj, (key, value) => {\n      if (value && typeof value === \"object\") {\n        result[key] = Utilities.recursiveClone(value);\n      } else {\n        result[key] = value;\n      }\n    });\n    return result;\n  }\n  static NEXT_ANONYMOUS_ID = 1;\n  static generateAnonymousModule() {\n    return \"===anonymous\" + Utilities.NEXT_ANONYMOUS_ID++ + \"===\";\n  }\n  static isAnonymousModule(id) {\n    return Utilities.startsWith(id, \"===anonymous\");\n  }\n  static PERFORMANCE_NOW_PROBED = false;\n  static HAS_PERFORMANCE_NOW = false;\n  static getHighPerformanceTimestamp() {\n    if (!this.PERFORMANCE_NOW_PROBED) {\n      this.PERFORMANCE_NOW_PROBED = true;\n      this.HAS_PERFORMANCE_NOW = _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.performance && typeof _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.performance.now === \"function\";\n    }\n    return this.HAS_PERFORMANCE_NOW ? _env__WEBPACK_IMPORTED_MODULE_0__.globalVar.performance.now() : Date.now();\n  }\n}\n\n//# sourceURL=webpack://__icube_loader__/./src/core/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core/main.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});